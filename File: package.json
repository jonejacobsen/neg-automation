{
  "name": "cleanup-test-01",
  "version": "1.0.0",
  "description": "Zapier CLI app: Testing after branch cleanup",
  "main": "index.js",
  "scripts": {
    "test": "jest"
  },
  "keywords": [
    "zapier",
    "cli",
    "trigger",
    "manual"
  ],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "zapier-platform-core": "^15.5.2"
  },
  "devDependencies": {
    "jest": "^29.6.1"
  }
}
```

```plaintext
# File: index.js
const { version } = require('./package.json');
const manualTrigger = require('./triggers/manual_trigger');

module.exports = {
  version,
  platformVersion: require('zapier-platform-core').version,
  triggers: {
    [manualTrigger.key]: manualTrigger,
  },
  // No authentication required
};
```

```plaintext
# File: triggers/manual_trigger.js
module.exports = {
  key: 'manual_trigger',
  noun: 'Test',
  display: {
    label: 'Manual Test Trigger',
    description: 'A manual trigger for testing after branch cleanup.',
    important: true,
  },

  operation: {
    perform: async (z, bundle) => {
      // Returns a static test provided object
      return [
        {
          id: 1,
          message: 'Branch cleanup test succeeded.',
          timestamp: new Date().toISOString(),
        },
      ];
    },
    // No inputFields
    sample: {
      id: 1,
      message: 'Branch cleanup test succeeded.',
      timestamp: '2024-01-01T00:00:00.000Z'
    },
    outputFields: [
      { key: 'id', label: 'ID', type: 'integer' },
      { key: 'message', label: 'Message', type: 'string' },
      { key: 'timestamp', label: 'Timestamp', type: 'string' },
    ],
  },
};
```

```plaintext
# File: __tests__/manual_trigger.test.js
const manualTrigger = require('../triggers/manual_trigger');

describe('manualTrigger', () => {
  test('should have correct key and noun', () => {
    expect(manualTrigger.key).toBe('manual_trigger');
    expect(manualTrigger.noun).toBe('Test');
  });

  test('should expose correct display information', () => {
    expect(manualTrigger.display.label).toBe('Manual Test Trigger');
    expect(manualTrigger.display.description).toMatch(/manual trigger/i);
    expect(manualTrigger.display.important).toBe(true);
  });

  test('should provide correct sample', () => {
    const sample = manualTrigger.operation.sample;
    expect(sample).toEqual({
      id: 1,
      message: 'Branch cleanup test succeeded.',
      timestamp: '2024-01-01T00:00:00.000Z'
    });
  });

  test('should define correct outputFields', () => {
    expect(manualTrigger.operation.outputFields).toEqual([
      { key: 'id', label: 'ID', type: 'integer' },
      { key: 'message', label: 'Message', type: 'string' },
      { key: 'timestamp', label: 'Timestamp', type: 'string' },
    ]);
  });

  test('perform should return array with correct structure', async () => {
    const z = {};
    const bundle = {};
    const result = await manualTrigger.operation.perform(z, bundle);
    expect(Array.isArray(result)).toBe(true);
    expect(result.length).toBe(1);

    const item = result[0];
    expect(item).toHaveProperty('id', 1);
    expect(item).toHaveProperty('message', 'Branch cleanup test succeeded.');
    expect(item).toHaveProperty('timestamp');
    // timestamp should be ISO string
    const d = new Date(item.timestamp);
    expect(typeof d.toISOString()).toBe('string');
    // Should be close to "now"
    const now = Date.now();
    const ts = Date.parse(item.timestamp);
    expect(Math.abs(ts - now)).toBeLessThan(1000 * 5); // within 5 seconds
  });
});
```

```plaintext
# File: __tests__/index.test.js
jest.mock('../package.json', () => ({
  version: '1.0.0'
}));

describe('index exports', () => {
  const app = require('../index.js');
  const manualTrigger = require('../triggers/manual_trigger');

  test('should export version', () => {
    expect(app.version).toBe('1.0.0');
  });

  test('should export platformVersion', () => {
    expect(app.platformVersion).toBeDefined();
    expect(typeof app.platformVersion).toBe('string');
  });

  test('should register the manual trigger', () => {
    expect(app.triggers[manualTrigger.key]).toBe(manualTrigger);
  });
});